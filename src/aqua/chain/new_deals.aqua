import Compare from "@fluencelabs/aqua-lib/math.aqua"
import or from "@fluencelabs/aqua-lib/binary.aqua"
import Spell, TriggerConfig from "@fluencelabs/spell/spell_service.aqua"

import FluenceAuroraConnector from "services.aqua"

import AuroraInfo from "aurora.aqua"
import spell_log from "../fluence/spell.aqua"
import Json from "../fluence/peer.aqua"
import process_deal from "../decider/decider.aqua"

use "../strings.aqua"


func poll_new_deals(spell_id: SpellId, info: AuroraInfo, from_block: string):
    Spell spell_id
    log = (msg: []‚ä§):
        spell_log(spell_id, msg)

    -- Obtain the number of the latest block in the chain on the first iteration
    -- (therefore proccess the deals from now on ignoring deals from the past), or
    -- when the from_block is "latest" (also can lead to ignoring some deals)
    from_block_init: *string
    counter <- get_counter(spell_id)
    is_first_iteration <- Compare.lte(counter, 1)
    is_latest <- Strings.eq(from_block, "latest")
    if or(is_first_iteration, is_latest):
        bnumber  <- FluenceAuroraConnector.latest_block_number(info.api_endpoint)
        if bnumber.success:
            log(["update from_block to the latest block: [init, new]", from_block, bnumber.result])
            bnumber_str <- Json.stringify(bnumber.result)
            Spell.set_string("from_block", bnumber_str)
            from_block_init <<- bnumber.result
    from_block_init <<- from_block
    real_from_block = from_block_init[0]

    result <- FluenceAuroraConnector.poll_deal_created(info.api_endpoint, info.address, real_from_block)
    if result.success == false:
        log(["can't receive info about new deals", result.error!])
    else:
        for deal <- result.result:
            log(["found deal", deal.info.deal_id, "from block", deal.block_number])
            if is_worker_created(spell_id, deal.info.deal_id):
                log(["worker for deal", deal.info.deal_id, "already created"])
            else:
                process_deal(spell_id, deal)
            new_from_block <- Json.stringify(deal.next_block_number)
            Spell.set_string("from_block", new_from_block)
        -- If we found no deals, we check if need to move the from_block forward
        -- We need to do it in case if no deals were done in range of 10000 blocks
        if result.result.length > 1 == false:
            need_update <- need_update_from_block(info.api_endpoint, result.to_block)
            if need_update:
                log(["updating outdated from_block: [previous from_block, new_from_block]", from_block, result.to_block])
                to_block_str <- Json.stringify(result.to_block)
                Spell.set_string("from_block", to_block_str)
