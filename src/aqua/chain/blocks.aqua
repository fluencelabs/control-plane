module Blocks declares get_latest, lte

import get_string, spell_log from "../fluence/spell.aqua"
import AuroraInfo from "../chain/aurora.aqua"
import SpellId from "../types.aqua"

import FluenceAuroraConnector from "services.aqua"

-- Get latest block number from RPC
func get_latest(spell_id: SpellId, chain: AuroraInfo) -> ?string:
    latest: ?string
    r <- FluenceAuroraConnector.latest_block_number(chain.api_endpoint)
    if r.success:
        latest <<- r.result
    else:
        spell_log(spell_id, ["error retrieving latest block number", r.error])
    <- latest

-- implements Less Than or Equal for two hex strings, i.e. `hex_a <= hex_b`
-- returns nil if either `hex_a` or `hex_b` is an invalid hex
func lte(spell_id: string, hex_a: string, hex_b: string) -> ?bool:
    less: ?bool

    cmp <- FluenceAuroraConnector.hex_cmp(hex_a, hex_b)
    if cmp.success:
        -- `hex_a` is less than `hex_b`
        if cmp.ordering == -1:
            less <<- true
        -- `hex_a` equals to `hex_b`
        if cmp.ordering == 0:
            less <<- true
        -- `hex_a` is greater than `hex_b`
        if cmp.ordering == 1:
            less <<- false
    else:
        spell_log(spell_id, ["hex_cmp error", cmp.error])

    <- less

-- Check if `to_block` is less than `latest_block` from chain.
-- If less, polling the range [from_block, to_block] won't yield new updates
-- and we need to move the range to be able to find updates.
-- func need_update_from_block(api_endpoint: string, to_block: string) -> bool:
--     need_update: *bool

--     result, is_ok <- get_latest_block(api_endpoint)
--     if is_ok:
--         -- if to_block is less then latest block, we need to update from_block and set it to to_block
--         need_update <<- lte(result!, to_block)
--     else:
--         need_update <<- false
--     <- need_update!
