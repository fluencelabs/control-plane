-- Plan:
-- * Support CID updates
-- * Implement decide function
--
import "@fluencelabs/spell/api.aqua"
import "@fluencelabs/spell/spell_service.aqua"
import "@fluencelabs/aqua-lib/builtin.aqua"
import "./fluence_aurora_connector.aqua"

-- Worker API
service Worker("worker"):
  -- throws exception if the worker already exists
  create(deal_id: string) -> string
  -- throws exception if the worker doesn't exist
  get_peer_id(deal_id: string) -> string


-- Extentions of the aqua lib
service Json("json"):
  parse(str: string) -> string
  stringify(obj: ⊤) -> string

service OpExt("op"):
  concat_strings(a1: string, a2: string, a3: string) -> string
  array_length(array: ⊤) -> u32

service JsonTriggerConfig("json"):
  parse(str: string) -> TriggerConfig

-- Wrapper over spell.get_string to get a string from spell's KV with reduced amount of if-else's
func get_string(spell_id: string, key: string) -> ?string, bool:
    Spell spell_id

    status: *bool
    result: *string

    value <- Spell.get_string(key)
    if value.success == false:
       status <<- false
    else:
       if value.absent:
          status <<- false
       else:
          result <<- value.str
          status <<- true
    <- result, status!

-- Debug outputs
service RunConsoleMany("run-console"):
   print(title: string, msg: []string)

service RunConsoleAny("run-console"):
   print(msg: []⊤)

func log(spell_id: string, msg: []string):
    title <- OpExt.concat_strings("decider <", spell_id, ">")
    RunConsoleMany.print(title, msg)
    msg_str <- Json.stringify(msg)
    Spell spell_id
    Spell.list_push_string("logs", msg_str)

-- Report error both in peer logs and in the spell's KV
func log_err(spell_id: string, error_msg: string):
    title <- OpExt.concat_strings("decider <", spell_id, ">")
    RunConsoleMany.print(title, [error_msg])
    Spell spell_id
    Spell.list_push_string("logged_errors", error_msg)

-- Arguments of the worker
data WorkerArgs:
    -- Address of the deal is also an ID of the deal
    deal_id: string
    -- CID of the worker's definition
    worker_def_cid: string
    -- IPFS API where the related CID resides
    ipfs: string

-- Stores info about created deals in the decider's KV
data JoinedDeal:
  deal_id: string
  spell_id: string

service JsonJoinedDeal("json"):
  parse(str: string) -> JoinedDeal

func store_joined_deal(spell_id: string, joined_deal: JoinedDeal):
    Spell spell_id
    msg <- Json.stringify(joined_deal)
    Spell.list_push_string("joined_deals", msg)

-- Find the worker for the corresponding deal.
-- We check all deals because we can't interrupt for-loop in aqua, but it's a nice
-- oportunity to check if the invariant (one worker per deal) is broken
func find_worker_by_deal(spell_id: string, deal_id: string) -> []string:
    result: *string

    Spell spell_id
    list <- Spell.list_get_strings("joined_deals")
    if list.success:
        for str <- list.strings:
            joined_deal <- JsonJoinedDeal.parse(str)
            if joined_deal.deal_id == deal_id:
                result <<- joined_deal.spell_id
    <- result

-- Check if a worker for a deal is already created
func is_worker_created(spell_id: string, deal_id: string) -> bool:
    workers <- find_worker_by_deal(spell_id, deal_id)
    len <- Op.array_length(workers)
    result: *bool
    if len == 0:
        result <<- false
    else:
        if len > 1:
            workers_str <- Json.stringify(workers)
            log_err(spell_id, Op.concat_strings("more than one worker for deal", deal_id))
            result <<- false
        else:
            result <<- true
    <- result!

-- Settings of the worker for the decider
data WorkerSettings:
  -- Trigger config of the worker
  worker_config: TriggerConfig
  -- Worker's AIR script
  worker_script: string
  -- IPFS API for the worker to pull info from
  worker_ipfs: string

-- Parse worker-settings from the decider's KV
func get_worker_settings(spell_id: string) ->  ?WorkerSettings, bool:
    Spell spell_id
    result: *bool
    settings: *WorkerSettings

    worker_script_str, is_ok1 <- get_string(spell_id, "worker_script")
    worker_config_str, is_ok2  <- get_string(spell_id, "worker_config")
    worker_ipfs_str, is_ok3  <- get_string(spell_id, "worker_ipfs")

    -- :c
    if is_ok1 == false:
        log_err(spell_id, "worker_script doesn't set")
        result <<- false
    else:
        if is_ok2 == false:
            log_err(spell_id, "worker_config doesn't set")
            result <<- false
        else:
            if is_ok3 == false:
                log_err(spell_id, "worker_ipfs doesn't set")
                result <<- false
            else:
                worker_script <- Json.parse(worker_script_str!)
                worker_config <- JsonTriggerConfig.parse(worker_config_str!)
                worker_ipfs <- Json.parse(worker_ipfs_str!)

                ws = WorkerSettings(worker_config = worker_config, worker_script = worker_script, worker_ipfs = worker_ipfs)
                settings <<- ws
                result <<- true
    <- settings, result!

-- 
-- The decider stores state of all processed deals:
-- * `skipped` means that the decider decided not to join the deal and won't join it.
-- * `joining` means that the deal started processing but wasn't processed 
func mark_deal_joining(spell_id: string, deal_id: string):
    Spell spell_id
    Spell.set_string(deal_id, "joining")

func mark_deal_joined(spell_id: string, deal_id: string):
    Spell spell_id
    Spell.set_string(deal_id, "joined")

func mark_deal_skipped(spell_id: string, deal_id: string):
    Spell spell_id
    Spell.set_string(deal_id, "skipped")

func get_deal_status(spell_id: string, deal_id: string) -> string:
    Spell spell_id
    status <- Spell.get_string(deal_id)
    <- status.str

---- The decider itself resides below

-- TODO: implement it when we decide what the algo should be there
func decide(deal: DealData) -> bool:
    <- true

-- 
func join_deal(spell_id: string, deal: DealData) -> bool:
    settings, is_ok <- get_worker_settings(spell_id)
    status: *bool
    if is_ok == false:
        status <<- false
    else:
        mark_deal_joining(spell_id, deal.deal_id)
        try:
            worker_id <- Worker.create(deal.deal_id)
            on worker_id:
                args = WorkerArgs(deal_id = deal.deal_id, worker_def_cid = deal.app_cid, ipfs = settings!.worker_ipfs)
                worker_spell_id <- PeerSpell.install(settings!.worker_script, args, settings!.worker_config)
                log(spell_id, ["created worker for deal", deal.deal_id, "spell_id", worker_spell_id, "worker_id", worker_id])
                mark_deal_joined(spell_id, deal.deal_id)
                joined_deal = JoinedDeal(deal_id = deal.deal_id, spell_id = worker_spell_id)
                store_joined_deal(spell_id, joined_deal)
                status <<- true

        catch e:
            log(spell_id, ["cannot create worker", deal.deal_id, e.message, "; skip"])
            mark_deal_joined(spell_id, deal.deal_id)
            status <<- false

    <- status!

func process_deal(spell_id: string, deal: DealCreated):
    if decide(deal.info) == false:
        log(spell_id, ["skipping deal for deal id", deal.info.deal_id, "from_block", deal.block_number])
        mark_deal_skipped(spell_id, deal.info.deal_id)
    else:
        log(spell_id, ["joining the deal", deal.info.deal_id, "from_block", deal.block_number])
        is_ok <- join_deal(spell_id, deal.info)
        if is_ok:
            log(spell_id, ["joined the deal", deal.info.deal_id])
        else:
            log(spell_id, ["couldn't join the deal", deal.info.deal_id])

-- To update the last seen from_block 
-- We store the last seen block to reduce the number of deals the poller provides us
data Update:
  from_block: string

-- Data we need to poll new deals from aurora
data AuroraInfo:
  -- Refers to which network to use:
  -- * testnet (refers to Aurora Testnet)
  -- * local (refers to the default local port)
  net: string
  -- Chain contract address
  address: string

func main(spell_id: string, listener_id: string, info: AuroraInfo, from_block: string) -> Update: 
    FluenceAuroraConnector listener_id
    update: *Update

    result <- FluenceAuroraConnector.poll_deals(info.net, info.address, from_block)
    if result.success == false:
        log_err(spell_id, result.error!)    
        update <<- Update(from_block = from_block)
    else:
        for deal <- result.result:
            log(spell_id, ["found deal", deal.info.deal_id])
            status <- get_deal_status(spell_id, deal.info.deal_id)
            if status == "joined":
                log(spell_id, ["skip joined deal", deal.info.deal_id])
            else:
                if status == "skipped":
                    log(spell_id, ["skip skipped deal", deal.info.deal_id])
                else:
                    if status == "joining":
                        log(spell_id, ["try to restore old deal in joining state", deal.info.deal_id])
                        if is_worker_created(spell_id, deal.info.deal_id):
                            log(spell_id, ["worker for the deal was already created, mark as joined", deal.info.deal_id])
                            mark_deal_joined(spell_id, deal.info.deal_id)
                        else:
                            -- Do not recreate, just skip for now to avoid recreating workers.
                            -- log(spell_id, ["no worker found, continue processing deal", deal.info.deal_id])
                            -- process_deal(spell_id, deal)
                            -- DEBUG:
                            log(spell_id, ["worker was marked as joining already", deal.info.deal_id, "skip it"])
                    else:
                        log(spell_id, ["will process deal", deal.info.deal_id])
                        process_deal(spell_id, deal)
        deals_num <- OpExt.array_length(result.result)
        if deals_num > 0:
            new_from_block = result.result[deals_num - 1].block_number
            update <<- Update(from_block = new_from_block)
        else:
            update <<- Update(from_block = from_block)
    <- update!
