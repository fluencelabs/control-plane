-- Phases:
-- 1. Create a spell that will be aquiring deal event from auroraconnector and doing nothing.
-- 2. Extend the spell with ability react on the event by installing simple oneshot spell.
-- 3. Install a worker instead of simple spell
--

import "@fluencelabs/spell/api.aqua"
import "@fluencelabs/spell/spell_service.aqua"
import "@fluencelabs/aqua-lib/builtin.aqua"
import "./fluence_aurora_connector.aqua"

data AuroraInfo:
  net: string
  address: string
  topics: []string

data Update:
  from_block: string

service RunConsole("run-console"):
   print(id: string, msg: string)

service RunConsole2("run-console"):
   print(msg: []string)


func report_err(spell_id: string, error_msg: string):
    Spell spell_id
    Spell.list_push_string("custom_error", error_msg)    

func main(spell_id: string, listener_id: string, info: AuroraInfo, from_block: string) -> Update: 
    FluenceAuroraConnector listener_id

    update: *Update

    result <- FluenceAuroraConnector.poll_deals(info.net, info.address, info.topics, from_block) 
    if result.success:
        RunConsole.print(spell_id, "ok")
        last_blocks: *string
        last_blocks <<- from_block
        for deal <- result.result:
            if from_block != deal.block_number:
                last_blocks <<- deal.block_number
                RunConsole.print(spell_id, deal.info.deal_id)
        len <- Op.array_length(last_blocks)
        new_from_block = last_blocks[len - 1]
        RunConsole.print(spell_id, new_from_block)
        update <<- Update(from_block = new_from_block)
    else:
        RunConsole.print(spell_id, result.error!)
        report_err(spell_id, result.error!)
        update <<- Update(from_block = from_block)


    --if result.success:
    --    -- blocks: *string
    --    for deal <- deals:
    --        -- blocks <<- deal.block_number
    --        decide(deal)   
    --    -- len <- Op.array_length(blocks)

   ---- How to update `from_block` value?
   -- <- from_block

    <- update!


-- func decide(deal: DealData) 
--     -- if hash(deal.info.deal_id) % 5
--     if true:
--         join_deal(deal.info)

-- func join_deal(deal: DealData):
--     PeerSpell.install(,,)

-- const APP_CID = "1234"
-- 
-- func join_deal(deal: DealData):
--    worker_keypair <- get_worker_peer_id(deal_id)
-- 
--    on worker_keypair.peer_id:
--        args = Args(deal_id = deal.address, app_cid = APP_CID)
--        config <- periodic(60)
--        Spell.install(script, args, config)
-- 
-- func periodic(period_sec: u32) -> TriggerConfig
--    <- TriggerConfig(
--         clock = ClockConfig(start_sec = 1, end_sec = 0, period_sec = period_sec),
--         connections = ConnectionPoolConfig(connect = false, disconnect = false),
--         blockchain = BlockChainConfig(start_block = 0, end_block = 0) 
--       )
-- 
-- func get_worker_peer_id(deal_id: Address) -> PeerId:
--   -- kp <- get_worker_keypair(deal_id)
--   -- <- kp.peer_id
--   <- Scope.get_peer_id()
