-- Plan:
-- * Support CID updates
-- * Implement decide function
--
import "@fluencelabs/spell/api.aqua"
import "@fluencelabs/spell/spell_service.aqua"
import "@fluencelabs/aqua-lib/builtin.aqua"
import "./fluence_aurora_connector.aqua"

-- Worker API
service Worker("worker"):
  -- throws exception if the worker already exists
  create(deal_id: string) -> string
  -- throws exception if the worker doesn't exist
  get_peer_id(deal_id: string) -> string


-- Extentions of the aqua lib
service Json("json"):
  parse(str: string) -> string
  stringify(obj: ⊤) -> string

service OpExt("op"):
  concat_strings(a1: string, a2: string, a3: string) -> string
  array_length(array: ⊤) -> u32

service JsonTriggerConfig("json"):
  parse(str: string) -> TriggerConfig

-- Wrapper over spell.get_string to get a string from spell's KV with reduced amount of if-else's
func get_string(spell_id: string, key: string) -> ?string, bool:
    Spell spell_id

    status: *bool
    result: *string

    value <- Spell.get_string(key)
    if value.success == false:
       status <<- false
    else:
       if value.absent:
          status <<- false
       else:
          result <<- value.str
          status <<- true
    <- result, status!

-- Debug outputs
service RunConsoleMany("run-console"):
   print(title: string, msg: []string)

service RunConsoleManyAny("run-console"):
   print(title: string, msg: []⊤)

service RunConsoleAny("run-console"):
   print(msg: []⊤)

func spell_log(spell_id: string, msg: []⊤):
    title <- OpExt.concat_strings("decider <", spell_id, ">")
    RunConsoleManyAny.print(title, msg)
    msg_str <- Json.stringify(msg)
    Spell spell_id
    Spell.list_push_string("logs", msg_str)

-- Arguments of the worker
data WorkerArgs:
    -- Address of the deal is also an ID of the deal
    deal_id: string
    -- CID of the worker's definition
    worker_def_cid: string
    -- IPFS API where the related CID resides
    ipfs: string

data DealState:
  from_block: string

service JsonDealState("json"):
  parse(str: string) -> DealState

func store_deal_state(spell_id: string, deal_id: string, state: DealState):
    Spell spell_id
    msg <- Json.stringify(state)
    Spell.set_string(deal_id, msg)

-- Stores info about created deals in the decider's KV
data JoinedDeal:
  deal_id: string
  spell_id: string
  worker_id: string

service JsonJoinedDeal("json"):
  parse(str: string) -> JoinedDeal

func store_joined_deal(spell_id: string, joined_deal: JoinedDeal):
    Spell spell_id
    msg <- Json.stringify(joined_deal)
    Spell.list_push_string("joined_deals", msg)

-- Check if a worker for a deal is already created
func is_worker_created(spell_id: string, deal_id: string) -> bool:
    result: *bool
    try:
        worker_id <- Worker.get_peer_id(deal_id)
        result <<- true
    otherwise:
        result <<- false
    <- result!

-- Settings of the worker for the decider
data WorkerSettings:
  -- Trigger config of the worker
  worker_config: TriggerConfig
  -- Worker's AIR script
  worker_script: string
  -- IPFS API for the worker to pull info from
  worker_ipfs: string

-- Parse worker-settings from the decider's KV
func get_worker_settings(spell_id: string) ->  ?WorkerSettings, bool:
    Spell spell_id
    log = (msg: ⊤):
        spell_log(spell_id, [msg])

    result: *bool
    settings: *WorkerSettings

    worker_script_str, is_ok1 <- get_string(spell_id, "worker_script")
    worker_config_str, is_ok2  <- get_string(spell_id, "worker_config")
    worker_ipfs_str, is_ok3  <- get_string(spell_id, "worker_ipfs")

    -- :c
    if is_ok1 == false:
        log("worker_script doesn't set")
        result <<- false
    else:
        if is_ok2 == false:
            log("worker_config doesn't set")
            result <<- false
        else:
            if is_ok3 == false:
                log("worker_ipfs doesn't set")
                result <<- false
            else:
                worker_script <- Json.parse(worker_script_str!)
                worker_config <- JsonTriggerConfig.parse(worker_config_str!)
                worker_ipfs <- Json.parse(worker_ipfs_str!)

                ws = WorkerSettings(worker_config = worker_config, worker_script = worker_script, worker_ipfs = worker_ipfs)
                settings <<- ws
                result <<- true
    <- settings, result!

-- TODO: implement it when we decide what the algo should be there
func decide(deal: DealCreatedData) -> bool:
    <- true

-- 
func join_deal(spell_id: string, block_number: string, deal: DealCreatedData) -> bool:
    log = (msg: []⊤):
        spell_log(spell_id, msg)

    settings, is_ok <- get_worker_settings(spell_id)
    status: *bool
    if is_ok == false:
        status <<- false
    else:
        try:
            worker_id <- Worker.create(deal.deal_id)
            on worker_id:
                args = WorkerArgs(deal_id = deal.deal_id, worker_def_cid = deal.app_cid, ipfs = settings!.worker_ipfs)
                worker_spell_id <- PeerSpell.install(settings!.worker_script, args, settings!.worker_config)
                log(["created worker for deal", deal.deal_id, "spell_id", worker_spell_id, "worker_id", worker_id])
                joined_deal = JoinedDeal(deal_id = deal.deal_id, spell_id = worker_spell_id, worker_id = worker_id)
                store_joined_deal(spell_id, joined_deal)
                deal_state = DealState(from_block = block_number)
                store_deal_state(spell_id, deal.deal_id, deal_state)
                status <<- true

        catch e:
            log(["cannot create worker", deal.deal_id, e.message, "; skip"])
            status <<- false

    <- status!

func process_deal(spell_id: string, deal: DealCreated):
    log = (msg: []⊤):
        spell_log(spell_id, msg)

    if decide(deal.info) == false:
        log(["skipping deal for deal id", deal.info.deal_id, "from_block", deal.block_number])
    else:
        log(["joining the deal", deal.info.deal_id, "from_block", deal.block_number])
        is_ok <- join_deal(spell_id, deal.block_number, deal.info)
        if is_ok:
            log(["joined the deal", deal.info.deal_id])
        else:
            log(["couldn't join the deal", deal.info.deal_id])

func get_latest_block(listener_id: string, net: string) -> ?string, bool:
    FluenceAuroraConnector listener_id
    is_ok: *bool
    block: *string

    result <- FluenceAuroraConnector.latest_block_number(net)
    if result.success == false:
        is_ok <<- false
    else:
        block <<- result.result
        is_ok <<- true

    <- block, is_ok!

-- Check if our local upper bound (to_block) until which we check new deals is outdated 
-- aka less then the latest block of the chain. 
func is_to_block_outdated(listener_id: string, latest_block: string, to_block: string) -> bool:
    FluenceAuroraConnector listener_id
    is: *bool

    -- diff = latest_block - to_block
    diff <- FluenceAuroraConnector.blocks_diff(to_block, latest_block)
    if diff == 0:
        is <<- false
    else:
        is <<- true
    <- is!

-- Check to the to_block is less than latest_block from chain.
-- That would meen that polling this range [from_block, to_block] won't give us new updated anymore 
-- and we need to move the range to be able to find updates.
func need_update_from_block(listener_id: string, net: string, to_block: string) -> bool:
    need_update: *bool

    result, is_ok <- get_latest_block(listener_id, net)
    if is_ok:
        -- if to_block is less then latest block, we need to update from_block and set it to to_block
        need_update <<- is_to_block_outdated(listener_id, result!, to_block)
    else:
        need_update <<- false
    <- need_update!

func poll_deal_changes_batch(spell_id: string, listener_id: string, net: string):
    FluenceAuroraConnector listener_id
    Spell spell_id
    log = (msg: []⊤):
        spell_log(spell_id, msg)

    -- Find the latest block on chain
    latest_block, is_block_ok <- get_latest_block(listener_id, net)

    -- Get all known deals
    list <- Spell.list_get_strings("joined_deals")
    if list.success == false:
        log(["can't restrive joined deals", list.error])
    else:
        -- Collect info about all known deals
        deals_update: *DealUpdate
        for joined_deal_str <- list.strings:
            joined_deal <- JsonJoinedDeal.parse(joined_deal_str)
            deal_str, is_ok <- get_string(spell_id, joined_deal.deal_id) 
            if is_ok == false:
                log(["can't find state of the deal", joined_deal.deal_id, "; broken invariant, check poll_new_deals"])
            else:
                deal_state <- JsonDealState.parse(deal_str!)
                deal_info = DealInfo(deal_id = joined_deal.deal_id, worker_id = joined_deal.worker_id)
                deals_update <<- DealUpdate(deal_info = deal_info, from_block = deal_state.from_block)

        -- Find the latest updates for all deals
        updated_deals <- FluenceAuroraConnector.poll_deals_latest_update_batch(net, deals_update)
        if updated_deals.success == false:
            log(["can't download deals updates", updated_deals.error!])
        else:
            -- Update all deals with new info
            for updated_deal <- updated_deals.result:
                if updated_deal.success == false:
                    log(["error retrieving deal update", updated_deal.deal_info.deal_id, updated_deal.error])
                    if is_block_ok:
                        if is_to_block_outdated(listener_id, latest_block!, updated_deal.to_block):
                            log(["update from_block: [new from_block, latest_block]", updated_deal.to_block, latest_block])
                            new_deal_state2 = DealState(from_block = updated_deal.to_block)
                            store_deal_state(spell_id, updated_deal.deal_info.deal_id, new_deal_state2)
                else:
                    log(["found update for deal", updated_deal.deal_info.deal_id, "from block", updated_deal.result!.block_number])

                    -- Update local info about the deal
                    new_deal_state = DealState(from_block = updated_deal.result!.next_block_number)
                    store_deal_state(spell_id, updated_deal.deal_info.deal_id, new_deal_state)

                    -- Update app_cid of the deal on the corresponding worker spell
                    log(["sending the latest update to the worker", updated_deal.deal_info])
                    on updated_deal.deal_info.worker_id:
                        -- stringify app_cid to be able to use it as an argument of a spell
                        app_cid <- Json.stringify(updated_deal.result!.info.app_cid)
                        Spell "worker-spell"
                        Spell.set_string("worker_def_cid", app_cid)

-- Data we need to poll new deals from aurora
data AuroraInfo:
  -- Refers to which network to use:
  -- * testnet (refers to Aurora Testnet)
  -- * local (refers to the default local port)
  net: string
  -- Chain contract address
  address: string

func get_counter(spell_id: string) -> u32:
    Spell spell_id
    result: *u32
    counter <- Spell.get_u32("counter")
    if counter.success:
        result <<- counter.num
    else:
        result <<- 0
    <- result!

func poll_new_deals(spell_id: string, listener_id: string, info: AuroraInfo, from_block: string): 
    FluenceAuroraConnector listener_id
    Spell spell_id
    log = (msg: []⊤):
        spell_log(spell_id, msg)

    -- On the first iteration of the spell obtain the number of the latest block in the chain
    -- And proccess the deals from now on ignoring deals from the past.
    from_block_init: *string
    counter <- get_counter(spell_id)
    if counter > 1 == false:
        bnumber  <- FluenceAuroraConnector.latest_block_number(info.net)
        if bnumber.success:
            log(["update from_block to the latest block: [init, new]", from_block, bnumber.result])
            bnumber_str <- Json.stringify(bnumber.result)
            Spell.set_string("from_block", bnumber_str) 
            from_block_init <<- bnumber.result
    from_block_init <<- from_block
    real_from_block = from_block_init[0]

    result <- FluenceAuroraConnector.poll_deals(info.net, info.address, real_from_block)
    if result.success == false:
        log(["can't receive info about new deals", result.error!])
    else:
        for deal <- result.result:
            log(["found deal", deal.info.deal_id, "from block", deal.block_number])
            if is_worker_created(spell_id, deal.info.deal_id):
                log(["worker for deal", deal.info.deal_id, "already created"])
            else:
                process_deal(spell_id, deal)
            new_from_block <- Json.stringify(deal.next_block_number)
            Spell.set_string("from_block", new_from_block) 
        -- If we found no deals, we check if need to move the from_block forward
        -- We need to do it in case if no deals were done in range of 10000 blocks
        if result.result.length > 1 == false:
            need_update <- need_update_from_block(listener_id, info.net, result.to_block)
            if need_update:
                log(["updating outdated from_block: [previous from_block, new_from_block]", from_block, result.to_block])
                to_block_str <- Json.stringify(result.to_block)
                Spell.set_string("from_block", to_block_str)

    
func main(spell_id: string, listener_id: string, info: AuroraInfo, from_block: string):
    -- Find new deals and create workers
    try:
        poll_new_deals(spell_id, listener_id, info, from_block)

    -- TODO: I wonder what will happen when the decider join _many_ deals?
    --       Will it be able to check them on time?
    -- Update existing deals
    poll_deal_changes_batch(spell_id, listener_id, info.net)
