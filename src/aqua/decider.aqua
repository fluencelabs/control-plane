-- Phases:
-- 4. Implement decide function
-- 

import "@fluencelabs/spell/api.aqua"
import "@fluencelabs/spell/spell_service.aqua"
import "@fluencelabs/aqua-lib/builtin.aqua"
import "./fluence_aurora_connector.aqua"

data AuroraInfo:
  net: string
  address: string
  topics: []string

data Update:
  from_block: string

service RunConsoleMany("run-console"):
   print(title: string, msg: []string)

-- debugging
service RunConsoleAny("run-console"):
   print(msg: []⊤)

service JsonTriggerConfig("json"):
  parse(str: string) -> TriggerConfig

service Json("json"):
  parse(str: string) -> string
  stringify(obj: ⊤) -> string

service OpExt("op"):
    concat_strings(a1: string, a2: string, a3: string) -> string

data WorkerArgs:
    deal_id: string
    worker_def_cid: string
    ipfs: string

data JoinedDeal:
  deal_id: string
  spell_id: string

data WorkerSettings:
  worker_config: TriggerConfig
  worker_script: string
  worker_ipfs: string

func print(spell_id: string, msg: []string):
   title <- OpExt.concat_strings("decider <", spell_id, ">")
   RunConsoleMany.print(title, msg)

func report_err(spell_id: string, error_msg: string):
    Spell spell_id
    Spell.list_push_string("custom_error", error_msg)

func report_warn(spell_id: string, msg: string):
    Spell spell_id
    Spell.list_push_string("custom_warning", msg)

func report_deal(spell_id: string, joined_deal: JoinedDeal):
    Spell spell_id
    msg <- Json.stringify(joined_deal) 
    Spell.list_push_string("joined_deals", msg)

-- TODO
func decide(deal: DealData) -> bool:
    <- true

func get_string(spell_id: string, key: string) -> ?string, bool:
    Spell spell_id

    status: *bool
    result: *string

    value <- Spell.get_string(key)
    if value.success == false:
       status <<- false
    else:
       if value.absent:
          status <<- false
       else:
          result <<- value.str
          status <<- true
    <- result, status!

func get_worker_settings(spell_id: string) ->  ?WorkerSettings, bool:
    Spell spell_id
    result: *bool
    settings: *WorkerSettings

    worker_script_str, is_ok1 <- get_string(spell_id, "worker_script")
    worker_config_str, is_ok2  <- get_string(spell_id, "worker_config")
    worker_ipfs_str, is_ok3  <- get_string(spell_id, "worker_ipfs")

    -- :c
    if is_ok1 == false:
        print(spell_id, ["worker_script doesn't set"])
        report_err(spell_id, "worker_script doesn't set")
        result <<- false
    else:
        if is_ok2 == false:
            print(spell_id, ["worker_config doesn't set"])
            report_err(spell_id, "worker_config doesn't set")
            result <<- false
        else:
            if is_ok3 == false:
                print(spell_id, ["worker_ipfs doesn't set"])
                report_err(spell_id, "worker_ipfs doesn't set")
                result <<- false
            else:
                worker_script <- Json.parse(worker_script_str!)
                worker_config <- JsonTriggerConfig.parse(worker_config_str!)
                worker_ipfs <- Json.parse(worker_ipfs_str!)

                ws = WorkerSettings(worker_config = worker_config, worker_script = worker_script, worker_ipfs = worker_ipfs)
                settings <<- ws
                result <<- true
    <- settings, result!

func mark_deal_joining(spell_id: string, deal_id: string):
    Spell spell_id
    Spell.set_string(deal_id, "joining")

func mark_deal_joined(spell_id: string, deal_id: string):
    Spell spell_id
    Spell.set_string(deal_id, "joined")

func join_deal(spell_id: string, deal: DealData) -> bool:
    settings, is_ok <- get_worker_settings(spell_id)
    status: *bool
    if is_ok == false:
        status <<- false
    else:
        mark_deal_joining(spell_id, deal.deal_id)
        -- TODO
        worker_peer_id <- Scope.get_peer_id() 
        on worker_peer_id:
            args = WorkerArgs(deal_id = deal.deal_id, worker_def_cid = deal.app_cid, ipfs = settings!.worker_ipfs)
            worker_spell_id <- PeerSpell.install(settings!.worker_script, args, settings!.worker_config)

        mark_deal_joined(spell_id, deal.deal_id)
        joined_deal = JoinedDeal(deal_id = deal.deal_id, spell_id = worker_spell_id)
        report_deal(spell_id, joined_deal)
        status <<- true
    <- status!

func get_deal_status(spell_id: string, deal_id: string) -> string:
    Spell spell_id
    status <- Spell.get_string(deal_id)
    <- status.str

func is_joined(spell_id: string, deal_id: string) -> bool:
    is_joined: *bool
    status <- get_deal_status(spell_id, deal_id)
    if status == "joined":
        is_joined <<- true
    else:
        is_joined <<- false
    <- is_joined!

func main(spell_id: string, listener_id: string, info: AuroraInfo, from_block: string) -> Update: 
    FluenceAuroraConnector listener_id

    -- For preserving new from_block value
    update: *Update

    result <- FluenceAuroraConnector.poll_deals(info.net, info.address, from_block) 
    if result.success:
        print(spell_id, ["found deals"])
        last_blocks: *string
        last_blocks <<- from_block

        for deal <- result.result:
             -- `from_block` is the latest seen block, so it's supposed that we already processed it.
             -- For initializing, we can use "latest" tag which isn't equal to any possible block numbers
             if is_joined(spell_id, deal.info.deal_id):
                print(spell_id, ["skip already joined deal", deal.info.deal_id])
             else:
                last_blocks <<- deal.block_number
                if decide(deal.info):
                    print(spell_id, ["joining the deal", deal.info.deal_id, "from_block", deal.block_number])
                    is_ok <- join_deal(spell_id, deal.info)
                    if is_ok:
                        print(spell_id, ["joined the deal", deal.info.deal_id])
                    else:
                        print(spell_id, ["couldn't join the deal", deal.info.deal_id])
                else:
                    print(spell_id, ["skipping deal for deal id", deal.info.deal_id, "from_block", deal.block_number])
                    msg <- Op.concat_strings("skipping ", deal.info.deal_id)
                    report_warn(spell_id, msg)
        
        -- Do it to detect the number of deals to find the last deal's block number
        len <- Op.array_length(last_blocks)
        new_from_block = last_blocks[len - 1]
        print(spell_id, ["all deals processed;", "old from_block", from_block, "new from_block", new_from_block])
        update <<- Update(from_block = new_from_block)
    else:
        -- report error somehow
        print(spell_id, result.error)
        report_err(spell_id, result.error!)
        -- since the last seen block didn't change we just 
        update <<- Update(from_block = from_block)

    <- update!
