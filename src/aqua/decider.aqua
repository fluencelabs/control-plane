-- Phases:
-- 1. Create a spell that will be aquiring deal event from auroraconnector and doing nothing.
-- 2. Extend the spell with ability react on the event by installing simple oneshot spell.
-- 3. Install a worker instead of simple spell
--

import "@fluencelabs/spell/api.aqua"
import "@fluencelabs/spell/spell_service.aqua"
import "@fluencelabs/aqua-lib/builtin.aqua"
import "./fluence_aurora_connector.aqua"

data AuroraInfo:
  net: string
  address: string
  topics: []string

data Update:
  from_block: string

service RunConsole("run-console"):
   print(id: string, msg: string)

service RunConsoleMany("run-console"):
   print(msg: []string)


func report_err(spell_id: string, error_msg: string):
    Spell spell_id
    Spell.list_push_string("custom_error", error_msg)    

func report_warn(spell_id: string, msg: string):
    Spell spell_id
    Spell.list_push_string("custom_warning", msg)    


func decide(deal: DealData) -> bool:
    <- true

service Json("json"):
  parse(str: string) -> TriggerConfig
  stringify(obj: âŠ¤) -> string

service JsonString("json"):
  parse(str: string) -> string


data WorkerArgs:
    deal_id: string
    app_cid: string

data JoinedDeal:
  deal_id: string
  spell_id: string

func join_deal(spell_id: string, deal: DealData):
    Spell spell_id
    worker_script_str = Spell.get_string("worker_script")
    worker_script <- JsonString.parse(worker_script_str.str)
    worker_config_str = Spell.get_string("worker_config")
    worker_config <- Json.parse(worker_config_str.str)

    worker_keypair = INIT_PEER_ID
    on worker_keypair:
        args = WorkerArgs(deal_id = deal.deal_id, app_cid = deal.app_cid)
        worker_spell_id <- PeerSpell.install(worker_script, args, worker_config)

    joined_deal = JoinedDeal(deal_id = deal.deal_id, spell_id = worker_spell_id)
    msg <- Json.stringify(joined_deal) 
    Spell.list_push_string("joined_deals", msg)

func main(spell_id: string, listener_id: string, info: AuroraInfo, from_block: string) -> Update: 
    FluenceAuroraConnector listener_id

    -- For preserving new from_block value
    update: *Update

    result <- FluenceAuroraConnector.poll_deals(info.net, info.address, info.topics, from_block) 
    if result.success:
        RunConsole.print(spell_id, "ok")
        last_blocks: *string
        last_blocks <<- from_block

        -- not `par` to be able to find the latest seen block number
        for deal <- result.result:
            -- `from_block` is the latest seen block, so it's supposed that we already processed it.
            -- For initializing, we can use "latest" tag which isn't equal to any possible block numbers
            if from_block != deal.block_number:
                last_blocks <<- deal.block_number
                RunConsole.print(spell_id, deal.info.deal_id)
                if decide(deal.info):
                    RunConsoleMany.print([spell_id, "joining the deal", deal.info.deal_id, "from_block", deal.block_number])
                    join_deal(spell_id, deal.info)
                else:
                    RunConsoleMany.print([spell_id, "skipping deal for deal id", deal.info.deal_id, "from_block", deal.block_number])
                    msg <- Op.concat_strings("skipping ", deal.info.deal_id)
                    report_warn(spell_id, msg)
        
        -- Do it to detect the latest seen block number
        len <- Op.array_length(last_blocks)
        new_from_block = last_blocks[len - 1]
        RunConsoleMany.print([spell_id, "new_from_block", new_from_block])
        update <<- Update(from_block = new_from_block)
    else:
        -- report error somehow
        RunConsole.print(spell_id, result.error!)
        report_err(spell_id, result.error!)
        -- since the last seen block didn't change we just 
        update <<- Update(from_block = from_block)

    <- update!
