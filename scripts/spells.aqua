import "@fluencelabs/aqua-lib/builtin.aqua"
import "@fluencelabs/spell/api.aqua"
import "@fluencelabs/spell/spell_service.aqua"

service PeerSpell3("spell"):
    install(script: string, init_data: ⊤, config: TriggerConfig) -> string

func get_peer_id() -> string:
    on HOST_PEER_ID:
        res <- Scope.get_peer_id()
    <- res

func list() -> []string:
   on HOST_PEER_ID:
      res <- PeerSpell.list()
   <- res

func install_data(script: string, cfg: TriggerConfig, dat: ⊤) -> string:
   on HOST_PEER_ID:
     sid <- PeerSpell3.install(script, dat, cfg)
   <- sid

-- func install(script: string, cfg: Config) -> string:
--    on HOST_PEER_ID:
--      sid <- PeerSpell.install(script, "{}", cfg)
--    <- sid
-- 
-- func check_script(spell_id: string) -> Script:
--   on HOST_PEER_ID:
--      Spell spell_id 
--      s <- Spell.get_script_source_from_file() 
--   <- s
-- 
-- 
func remove(spell_id: string):
  on HOST_PEER_ID:
     PeerSpell.remove(spell_id)
-- 
-- service Debug("debug"):
--     -- Convert any object into a string
--     stringify(o: ⊤) -> string
-- 
-- func get_u32(spell_id: string, key: string) -> U32Value:
--   on HOST_PEER_ID:
--     Spell spell_id
--     r <- Spell.get_u32(key)
--   <- r
-- 
-- func get_string(spell_id: string, key: string) -> StringValue:
--   on HOST_PEER_ID:
--     Spell spell_id
--     r <- Spell.get_string(key)
--   <- r
-- 
-- 
-- func set_u32(spell_id: string, key: string, val: u32) -> UnitResult:
--   on HOST_PEER_ID:
--     Spell spell_id
--     r <- Spell.set_u32(key, val)
--   <- r
-- 
-- 

service PeerSpell2("spell"):
    update_trigger_config(spell_id: string, cfg: TriggerConfig)

func update(spell_id: string, cfg: TriggerConfig):
   on HOST_PEER_ID:
     PeerSpell2.update_trigger_config(spell_id, cfg)

func is_absent(spell_id: string) -> bool:
  result: *bool
  on HOST_PEER_ID:
    try:
        Spell spell_id
        Spell.get_script_source_from_file()
        result <<- false
    otherwise:
        result <<- true
  <- result[0]

func timeout(dur: u64, msg: string) -> string:
  on HOST_PEER_ID:
    res <- Peer.timeout(dur, msg)
  <- res

func get_logs(spell_id: string) -> StringListValue:
    on HOST_PEER_ID:
        Spell spell_id
        x <- Spell.list_get_strings("logs")
    <- x
